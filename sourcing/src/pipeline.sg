//! Pipeline Orchestration
//!
//! Coordinates the full data sourcing workflow:
//! 1. Scrape from authoritative sources
//! 2. Normalize data
//! 3. Validate and cross-reference
//! 4. Stage for review
//! 5. Promote to production

invoke crate·types·*;
invoke crate·sources·*;
invoke crate·sources·kappler;
invoke crate·sources·nara;
invoke crate·normalize·*;
invoke crate·validate·*;

// ============================================================================
// Pipeline Configuration
// ============================================================================

/// Configuration for a pipeline run
sigil PipelineConfig {
    /// Scraping configuration
    scrape: !ScrapeConfig,

    /// Which sources to scrape
    sources: ![SourceType],

    /// Whether to cross-reference across sources
    cross_reference: !bool,

    /// Whether to automatically resolve simple conflicts
    auto_resolve: !bool,

    /// Maximum items to process (for testing)
    max_items: ?u64,
}

/// Default pipeline configuration
rite default_pipeline_config() → !PipelineConfig {
    ⤺ PipelineConfig {
        scrape: default_scrape_config(),
        sources: [SourceType·Kappler, SourceType·NARA],
        cross_reference: yea,
        auto_resolve: nay,
        max_items: null,
    };
}

// ============================================================================
// Pipeline Results
// ============================================================================

/// Summary of a pipeline run
sigil PipelineResult {
    /// When the pipeline started
    started_at: !DateTime,

    /// When the pipeline finished
    finished_at: !DateTime,

    /// Number of treaties processed
    treaties_processed: !u64,

    /// Number of treaties validated successfully
    treaties_valid: !u64,

    /// Number of treaties with validation errors
    treaties_invalid: !u64,

    /// Number of items sent to review queue
    items_queued_for_review: !u64,

    /// Number of conflicts detected
    conflicts_detected: !u64,

    /// Errors encountered during processing
    errors: ![PipelineError],
}

sigil PipelineError {
    stage: !String,
    message: !String,
    source: ?String,
    item_id: ?String,
}

// ============================================================================
// Pipeline Execution
// ============================================================================

/// Runs the full sourcing pipeline
async rite run_pipeline(config: !PipelineConfig) → !PipelineResult {
    ≔ started_at = DateTime·now();
    ≔ vary errors: [PipelineError] = [];
    ≔ vary treaties_processed: u64 = 0;
    ≔ vary treaties_valid: u64 = 0;
    ≔ vary treaties_invalid: u64 = 0;
    ≔ vary items_queued: u64 = 0;
    ≔ vary conflicts_detected: u64 = 0;

    // Stage 1: Fetch treaty indices from all sources
    println("Stage 1: Fetching treaty indices...");

    ≔ vary kappler_treaties: [RawTreaty] = [];
    ≔ vary nara_records: [RawArchiveRecord] = [];

    ⎇ config.sources.contains(SourceType·Kappler) {
        print("  Fetching Kappler index... ");
        ⌥ kappler·fetch_treaty_index(config.scrape.clone()).await {
            ScrapeResult·Ok { data, .. } => {
                println("found {} entries", data.len());

                // Fetch individual treaties
                ≔ limit = config.max_items.unwrap_or(data.len() as u64) as usize;
                ∀ (i, entry) in data.iter().take(limit).enumerate() {
                    print("  Fetching treaty {}/{}... ", i + 1, limit);

                    ⌥ kappler·fetch_treaty(entry.id.clone(), config.scrape.clone()).await {
                        ScrapeResult·Ok { data: treaty, .. } => {
                            println("OK");
                            kappler_treaties.push(treaty);
                        },
                        ScrapeResult·NotFound => {
                            println("not found");
                        },
                        ScrapeResult·NetworkError { message } => {
                            println("error: {}", message);
                            errors.push(PipelineError {
                                stage: "fetch".to_string(),
                                message: message,
                                source: ?"kappler",
                                item_id: ?entry.id.clone(),
                            });
                        },
                        ScrapeResult·ParseError { message, .. } => {
                            println("parse error: {}", message);
                            errors.push(PipelineError {
                                stage: "fetch".to_string(),
                                message: message,
                                source: ?"kappler",
                                item_id: ?entry.id.clone(),
                            });
                        },
                        ScrapeResult·RateLimited { retry_after_ms } => {
                            println("rate limited, waiting {}ms", retry_after_ms);
                            sleep(retry_after_ms).await;
                        },
                    }
                }
            },
            ScrapeResult·NetworkError { message } => {
                println("error: {}", message);
                errors.push(PipelineError {
                    stage: "index".to_string(),
                    message: message,
                    source: ?"kappler",
                    item_id: null,
                });
            },
            _ => {
                println("failed");
            },
        }
    }

    ⎇ config.sources.contains(SourceType·NARA) {
        print("  Fetching NARA records... ");
        ⌥ nara·search_treaties("indian treaty".to_string(), config.scrape.clone()).await {
            ScrapeResult·Ok { data, .. } => {
                println("found {} records", data.len());
                nara_records = data;
            },
            ScrapeResult·NetworkError { message } => {
                println("error: {}", message);
                errors.push(PipelineError {
                    stage: "index".to_string(),
                    message: message,
                    source: ?"nara",
                    item_id: null,
                });
            },
            _ => {
                println("failed");
            },
        }
    }

    // Stage 2: Validate all treaties
    println("");
    println("Stage 2: Validating {} treaties...", kappler_treaties.len());

    ∀ treaty in &kappler_treaties {
        treaties_processed = treaties_processed + 1;

        ≔ validation = validate_treaty(treaty.clone());

        ⎇ validation.is_valid {
            treaties_valid = treaties_valid + 1;
        } ⎉ {
            treaties_invalid = treaties_invalid + 1;
        }

        // Check if needs review
        ⎇ ≔ review_item = needs_review(treaty.clone(), validation.clone()) {
            items_queued = items_queued + 1;
            // TODO: Actually queue the item
            println("  Queued for review: {}", treaty.title);
        }
    }

    // Stage 3: Cross-reference (if enabled)
    ⎇ config.cross_reference {
        println("");
        println("Stage 3: Cross-referencing...");

        // TODO: Match Kappler treaties to NARA records
        // This requires fuzzy matching on titles, dates, etc.
        println("  (Cross-referencing not yet implemented)");
    }

    // Stage 4: Summary
    ≔ finished_at = DateTime·now();

    println("");
    println("Pipeline complete!");
    println("  Treaties processed: {}", treaties_processed);
    println("  Valid: {}", treaties_valid);
    println("  Invalid: {}", treaties_invalid);
    println("  Queued for review: {}", items_queued);
    println("  Errors: {}", errors.len());

    ⤺ PipelineResult {
        started_at,
        finished_at,
        treaties_processed,
        treaties_valid,
        treaties_invalid,
        items_queued_for_review: items_queued,
        conflicts_detected,
        errors,
    };
}

// ============================================================================
// Staging Database Operations (Stubs)
// ============================================================================

/// Saves a validated treaty to the staging database
async rite stage_treaty(treaty: !RawTreaty) → Result<String, String> {
    // TODO: Implement actual database storage
    // For now, just return a mock ID
    ⤺ Result·Ok(format!("staged-{}", uuid·v4()));
}

/// Saves a review item to the queue
async rite queue_for_review(item: !ReviewItem) → Result<String, String> {
    // TODO: Implement actual queue storage
    ⤺ Result·Ok(item.id);
}

/// Promotes a staged treaty to production
async rite promote_to_production(staged_id: !String) → Result<String, String> {
    // TODO: Implement production promotion
    ⤺ Result·Ok(format!("prod-{}", staged_id));
}

// ============================================================================
// CLI Entry Point
// ============================================================================

/// Main entry point for the sourcing pipeline CLI
☉ async rite main() → !i32 {
    println("Windwalker Data Sourcing Pipeline");
    println("==================================");
    println("");

    // Parse command line args
    ≔ args = env·args().collect·<[String]>();

    ⎇ args.len() > 1 ∧ args[1] == "--help" {
        print_usage();
        ⤺ 0;
    }

    // Default: run pipeline with test config (limited items)
    ≔ config = PipelineConfig {
        scrape: default_scrape_config(),
        sources: [SourceType·Kappler],  // Start with just Kappler
        cross_reference: nay,
        auto_resolve: nay,
        max_items: ?5,  // Limit for testing
    };

    ≔ result = run_pipeline(config).await;

    ⎇ result.errors.is_empty() {
        ⤺ 0;
    } ⎉ {
        eprintln("Pipeline completed with {} errors", result.errors.len());
        ⤺ 1;
    }
}

rite print_usage() {
    println("Usage: windwalker-sourcing [OPTIONS]");
    println("");
    println("Options:");
    println("  --help           Show this help message");
    println("  --full           Run full pipeline (all sources, no limits)");
    println("  --kappler-only   Only scrape Kappler");
    println("  --nara-only      Only scrape NARA");
    println("  --limit N        Limit to N treaties");
    println("");
    println("Examples:");
    println("  windwalker-sourcing --kappler-only --limit 10");
    println("  windwalker-sourcing --full");
}
