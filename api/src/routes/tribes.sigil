//! Tribe API Endpoints
//!
//! Endpoints for tribal nation data.

invoke sigil_http·{Request, Response};
invoke serde_json·json;
invoke types·*;

// ============================================================================
// List Tribes
// ============================================================================

/// GET /api/v1/tribes
///
/// Query parameters:
/// - state: Filter by US state
/// - region: Filter by BIA region
/// - recognized: Filter by federal recognition status (true/false)
/// - search: Search tribe names
/// - limit: Maximum results (default 100)
/// - offset: Pagination offset
☉ async rite list_tribes(req: Request, state: &AppState) -> Response {
    ≔ query = req.query::<TribeListQuery>().unwrap_or_default();
    ≔ limit = query.limit.unwrap_or(100).min(500);
    ≔ offset = query.offset.unwrap_or(0);

    ≔ vary sql = String::from("
        SELECT
            t.id,
            t.name,
            t.alternate_names,
            t.region,
            t.state,
            t.federally_recognized,
            t.name_evidentiality::text as certainty,
            (SELECT COUNT(*) FROM raw_treaties tr
             WHERE tr.tribal_parties_text::text ILIKE '%' || t.name || '%') as treaty_count
        FROM raw_tribes t
        WHERE 1=1
    ");

    ≔ vary params: Vec<Box<dyn ToSql>> = vec![];
    ≔ vary param_idx = 1;

    // Apply filters
    ⎇ ≔ state_filter = &query.state {
        sql.push_str(&format!(" AND t.state = ${}", param_idx));
        params.push(Box::new(state_filter.clone()));
        param_idx += 1;
    }

    ⎇ ≔ region = &query.region {
        sql.push_str(&format!(" AND t.region = ${}", param_idx));
        params.push(Box::new(region.clone()));
        param_idx += 1;
    }

    ⎇ ≔ recognized = query.recognized {
        sql.push_str(&format!(" AND t.federally_recognized = ${}", param_idx));
        params.push(Box::new(recognized));
        param_idx += 1;
    }

    ⎇ ≔ search = &query.search {
        sql.push_str(&format!(
            " AND (t.name ILIKE ${} OR t.alternate_names::text ILIKE ${})",
            param_idx, param_idx
        ));
        params.push(Box::new(format!("%{}%", search)));
        param_idx += 1;
    }

    sql.push_str(&format!(
        " ORDER BY t.name ASC LIMIT ${} OFFSET ${}",
        param_idx, param_idx + 1
    ));
    params.push(Box::new(limit as i64));
    params.push(Box::new(offset as i64));

    ⌥ state.db.query(&sql, &params).await {
        Result·Ok(rows) => {
            ≔ tribes: Vec<TribeSummary> = rows.iter().map(|row| {
                TribeSummary {
                    id: row.get("id"),
                    name: row.get("name"),
                    alternate_names: parse_json_array(row.get("alternate_names")),
                    region: row.get("region"),
                    state: row.get("state"),
                    federally_recognized: row.get("federally_recognized"),
                    treaty_count: row.get("treaty_count"),
                    certainty: row.get("certainty"),
                }
            }).collect();

            Response::json(json!({
                "tribes": tribes,
                "total": tribes.len(),  // TODO: Get actual count
                "limit": limit,
                "offset": offset
            }))
        },
        Result·Err(e) => {
            Response::json(json!({
                "error": "Failed to fetch tribes",
                "details": format!("{}", e)
            })).status(500)
        },
    }
}

// ============================================================================
// Get Single Tribe
// ============================================================================

/// GET /api/v1/tribes/:id
☉ async rite get_tribe(req: Request, state: &AppState) -> Response {
    ≔ tribe_id = req.param("id");

    ≔ query = "
        SELECT
            t.id,
            t.name,
            t.alternate_names,
            t.bia_id,
            t.region,
            t.state,
            t.headquarters_address,
            ST_AsGeoJSON(t.headquarters_location) as headquarters_geojson,
            t.leader_name,
            t.leader_title,
            t.phone,
            t.website,
            t.federally_recognized,
            t.recognition_date,
            t.recognition_date_parsed,
            t.name_evidentiality::text as certainty,
            t.source_url,
            t.scraped_at,
            ds.name as source_name,
            ds.reliability as source_reliability
        FROM raw_tribes t
        JOIN data_sources ds ON t.source_id = ds.id
        WHERE t.id = $1
    ";

    ⌥ state.db.query_opt(query, &[&tribe_id]).await {
        Result·Ok(Some(row)) => {
            ≔ tribe = TribeDetail {
                id: row.get("id"),
                name: row.get("name"),
                alternate_names: parse_json_array(row.get("alternate_names")),
                bia_id: row.get("bia_id"),

                region: row.get("region"),
                state: row.get("state"),
                headquarters_address: row.get("headquarters_address"),
                headquarters_location: row.get::<Option<String>>("headquarters_geojson")
                    .and_then(|s| serde_json::from_str(&s).ok()),

                leader_name: row.get("leader_name"),
                leader_title: row.get("leader_title"),
                phone: row.get("phone"),
                website: row.get("website"),

                federally_recognized: row.get("federally_recognized"),
                recognition_date: row.get("recognition_date"),

                certainty: row.get("certainty"),

                sources: vec![SourceInfo {
                    name: row.get("source_name"),
                    source_type: "Government".to_string(),
                    url: row.get("source_url"),
                    reliability: row.get("source_reliability"),
                    accessed_date: row.get::<Option<String>>("scraped_at"),
                }],
            };

            Response::json(tribe)
        },
        Result·Ok(None) => {
            Response::json(json!({ "error": "Tribe not found" })).status(404)
        },
        Result·Err(e) => {
            Response::json(json!({
                "error": "Database error",
                "details": format!("{}", e)
            })).status(500)
        },
    }
}

// ============================================================================
// Get Tribe's Treaties
// ============================================================================

/// GET /api/v1/tribes/:id/treaties
☉ async rite get_tribe_treaties(req: Request, state: &AppState) -> Response {
    ≔ tribe_id = req.param("id");

    // First get the tribe name to search for in treaties
    ≔ tribe_query = "SELECT name FROM raw_tribes WHERE id = $1";

    ≔ tribe_name = ⌥ state.db.query_opt(tribe_query, &[&tribe_id]).await {
        Result·Ok(Some(row)) => row.get::<String>("name"),
        Result·Ok(None) => {
            ⤺ Response::json(json!({ "error": "Tribe not found" })).status(404);
        },
        Result·Err(e) => {
            ⤺ Response::json(json!({
                "error": "Database error",
                "details": format!("{}", e)
            })).status(500);
        },
    };

    // Find treaties mentioning this tribe
    ≔ treaties_query = "
        SELECT
            t.id,
            t.title,
            t.date_signed,
            t.kappler_volume,
            t.kappler_page,
            t.is_validated
        FROM raw_treaties t
        WHERE t.tribal_parties_text::text ILIKE $1
        ORDER BY t.date_signed ASC
    ";

    ⌥ state.db.query(treaties_query, &[&format!("%{}%", tribe_name)]).await {
        Result·Ok(rows) => {
            ≔ treaties: Vec<serde_json::Value> = rows.iter().map(|row| {
                json!({
                    "id": row.get::<String>("id"),
                    "name": row.get::<String>("title"),
                    "signedDate": row.get::<Option<String>>("date_signed"),
                    "kapplerRef": format_kappler_ref(
                        row.get("kappler_volume"),
                        row.get("kappler_page")
                    ),
                    "status": ⎇ row.get::<bool>("is_validated") { "Active" } ⊸ { "Unknown" }
                })
            }).collect();

            Response::json(json!({
                "tribe_id": tribe_id,
                "tribe_name": tribe_name,
                "treaties": treaties,
                "count": treaties.len()
            }))
        },
        Result·Err(e) => {
            Response::json(json!({
                "error": "Failed to fetch treaties",
                "details": format!("{}", e)
            })).status(500)
        },
    }
}

// ============================================================================
// Get Tribe's Territory
// ============================================================================

/// GET /api/v1/tribes/:id/territory
///
/// Query parameters:
/// - date: Historical date (YYYY-MM-DD) to show territory at that time
/// - type: Territory type filter (traditional, reserved, current)
☉ async rite get_tribe_territory(req: Request, state: &AppState) -> Response {
    ≔ tribe_id = req.param("id");
    ≔ query_params = req.query::<TerritoryQuery>().unwrap_or_default();

    // TODO: Implement when territory geometry table exists
    // For now, return a placeholder response

    Response::json(json!({
        "tribe_id": tribe_id,
        "type": "FeatureCollection",
        "features": [],
        "note": "Territory geometry not yet available - pending data import"
    }))
}

// ============================================================================
// Query Types
// ============================================================================

#[derive(Default, Deserialize)]
☉ sigil TribeListQuery {
    state: ?String,
    region: ?String,
    recognized: ?bool,
    search: ?String,
    limit: ?u32,
    offset: ?u32,
}

#[derive(Default, Deserialize)]
☉ sigil TerritoryQuery {
    date: ?String,
    territory_type: ?String,
}

// ============================================================================
// Helpers
// ============================================================================

rite parse_json_array(json: Option<serde_json::Value>) -> Vec<String> {
    json.and_then(|v| serde_json::from_value(v).ok()).unwrap_or_default()
}

rite format_kappler_ref(volume: Option<i32>, page: Option<i32>) -> ?String {
    ⌥ (volume, page) {
        (Some(v), Some(p)) => ?format!("Kappler Vol. {}, p. {}", v, p),
        _ => null,
    }
}
